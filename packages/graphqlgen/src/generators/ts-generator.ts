import * as os from 'os'
import * as prettier from 'prettier'

import { CodeFileLike, GenerateArgs, ModelMap, ContextDefinition } from '../types'
import { GraphQLTypeField, GraphQLTypeObject } from '../source-helper'
import {
  renderDefaultResolverMethods,
  renderDefaultResolvers,
  getContextName,
  getModelName,
  TypeToInputTypeAssociation,
  InputTypesMap,
  printFieldLikeType,
  getDistinctInputTypes,
  renderEnums,
  groupModelsNameByImportPath,
  shouldScaffoldFieldResolver,
  fieldsFromModelDefinition
} from './common'
import { TypeAliasDefinition } from '../introspection/types'
import { upperFirst } from '../utils'

export function format(code: string, options: prettier.Options = {}) {
  try {
    return prettier.format(code, {
      ...options,
      parser: 'typescript',
    })
  } catch (e) {
    console.log(
      `There is a syntax error in generated code, unformatted code printed, error: ${JSON.stringify(
        e,
      )}`,
    )
    return code
  }
}

export function generate(args: GenerateArgs): CodeFileLike[] {
  // TODO: Maybe move this to source helper
  const inputTypesMap: InputTypesMap = args.types
    .filter(type => type.type.isInput)
    .reduce((inputTypes, type) => {
      return {
        ...inputTypes,
        [`${type.name}`]: type,
      }
    }, {})

  // TODO: Type this
  const typeToInputTypeAssociation: TypeToInputTypeAssociation = args.types
    .filter(
      type =>
        type.type.isObject &&
        type.fields.filter(
          field => field.arguments.filter(arg => arg.type.isInput).length > 0,
        ).length > 0,
    )
    .reduce((types, type) => {
      return {
        ...types,
        [`${type.name}`]: [].concat(
          ...(type.fields.map(field =>
            field.arguments
              .filter(arg => arg.type.isInput)
              .map(arg => arg.type.name),
          ) as any),
        ),
      }
    }, {})

  let files: CodeFileLike[] = args.types
    .filter(type => type.type.isObject)
    .map(type => generateTypeFile(type, args, typeToInputTypeAssociation, inputTypesMap))

  // TODO: add index file
  files.push({
    path: 'index.ts',
    force: false,
    code: renderIndex(args.types),
  })

  return files
}

function renderHeader(args: GenerateArgs): string {
  const modelsToImport = Object.keys(args.modelMap)
    .filter(modelName => {
      const modelDef = args.modelMap[modelName].definition

      return !(
        modelDef.kind === 'TypeAliasDefinition' &&
        (modelDef as TypeAliasDefinition).isEnum
      )
    })
    .map(modelName => args.modelMap[modelName])
  const modelsByImportPaths = groupModelsNameByImportPath(modelsToImport)

  const modelImports = Object.keys(modelsByImportPaths)
    .map(
      importPath =>
        `import { ${modelsByImportPaths[importPath].join(
          ', ',
        )} } from '${importPath}'`,
    )
    .join(os.EOL)

  return `
// Code generated by github.com/prisma/graphqlgen, DO NOT EDIT.

import { GraphQLResolveInfo } from 'graphql'
${modelImports}
${renderContext(args.context)}
  `
}

function renderContext(context?: ContextDefinition) {
  if (context) {
    return `import { ${getContextName(context)} } from '${context.contextPath}'`
  }

  return `type ${getContextName(context)} = any`
}

function generateTypeFile(
  graphQLTypeObject: GraphQLTypeObject,
  args: GenerateArgs,
  typeToInputTypeAssociation: TypeToInputTypeAssociation,
  inputTypesMap: InputTypesMap,
): CodeFileLike {

  const code = `\
    ${renderHeader(args)}

    ${renderEnums(args)}

    ${renderDefaultResolvers(graphQLTypeObject, args, 'defaultResolvers')}

    ${renderInputTypeInterfaces(
      graphQLTypeObject,
      args.modelMap,
      typeToInputTypeAssociation,
      inputTypesMap,
    )}

    ${renderInputArgInterfaces(graphQLTypeObject, args.modelMap)}

    ${renderResolverFunctionInterfaces(
      graphQLTypeObject,
      args.modelMap,
      args.context,
    )}

    ${renderResolverTypeInterface(
      graphQLTypeObject,
      args.modelMap,
      args.context,
    )}

    ${renderAbstractClass(graphQLTypeObject, args)}
  `
  return { path: `${graphQLTypeObject.name}.ts`, force: false, code }
}

function renderAbstractClass(
  graphQLTypeObject: GraphQLTypeObject,
  args: GenerateArgs, 
): string {

  const interfaceName = getInterfaceName(graphQLTypeObject.name)
  const className = getClassName(graphQLTypeObject.name)

  return `export abstract class ${className} implements ${interfaceName} {
    ${renderDefaultResolverMethods(graphQLTypeObject, args)}

    ${renderAbstractResolverMethods(graphQLTypeObject, args)}
  }`
}

function renderAbstractResolverMethods(
  type: GraphQLTypeObject,
  args: GenerateArgs
): string {
  const model = args.modelMap[type.name]
  const modelFields = model ? fieldsFromModelDefinition(model.definition) : []

  return type.fields
    .filter(field => shouldScaffoldFieldResolver(field, modelFields, args))
    .map(field =>
      renderAbstractResolverMethod(field, type, args.modelMap, args.context),
    )
    .join(os.EOL)
}

function renderAbstractResolverMethod(
  field: GraphQLTypeField,
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  context?: ContextDefinition,
): string {
  const resolverDefinition = getResolverDefinition(field, type, modelMap, context)
  const returnType = printFieldLikeType(field, modelMap)

  return `
  abstract ${field.name} ${resolverDefinition}: ${returnType} | Promise<${returnType}>
  `
}

function renderInputTypeInterfaces(
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  typeToInputTypeAssociation: TypeToInputTypeAssociation,
  inputTypesMap: InputTypesMap,
) {
  if (!typeToInputTypeAssociation[type.name]) {
    return ``
  }

  return getDistinctInputTypes(type, typeToInputTypeAssociation, inputTypesMap)
    .map(typeAssociation => {
      return `export interface ${inputTypesMap[typeAssociation].name} {
      ${inputTypesMap[typeAssociation].fields.map(
        field => `${field.name}: ${printFieldLikeType(field, modelMap)}`,
      )}
    }`
    })
    .join(os.EOL)
}

function renderInputArgInterfaces(
  type: GraphQLTypeObject,
  modelMap: ModelMap,
): string {
  return type.fields
    .map(field => renderInputArgInterface(field, modelMap))
    .join(os.EOL)
}

function renderInputArgInterface(
  field: GraphQLTypeField,
  modelMap: ModelMap,
): string {
  if (field.arguments.length === 0) {
    return ''
  }

  return `
  export interface Args${upperFirst(field.name)} {
    ${field.arguments
      .map(
        arg =>
          `${arg.name}: ${printFieldLikeType(
            arg as GraphQLTypeField,
            modelMap,
          )}`,
      )
      .join(os.EOL)}
  }
  `
}

function renderResolverFunctionInterfaces(
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  context?: ContextDefinition,
): string {
  return type.fields
    .map(field =>
      renderResolverFunctionInterface(field, type, modelMap, context),
    )
    .join(os.EOL)
}

function renderResolverFunctionInterface(
  field: GraphQLTypeField,
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  context?: ContextDefinition,
): string {
  const resolverName = `${upperFirst(field.name)}Resolver`
  const resolverDefinition = getResolverDefinition(field, type, modelMap, context)
  const returnType = printFieldLikeType(field, modelMap)

  if (type.name === 'Subscription') {
    return `
    export type ${resolverName} = {
      subscribe: ${resolverDefinition} => AsyncIterator<${returnType}> | Promise<AsyncIterator<${returnType}>>
      resolve?: ${resolverDefinition} => ${returnType} | Promise<${returnType}>
    }
    `
  }

  return `
  export type ${resolverName} = ${resolverDefinition} => ${returnType} | Promise<${returnType}>
  `
}

function getResolverDefinition(
  field: GraphQLTypeField,
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  context?: ContextDefinition,
): string {
  return `
  (
    parent: ${getModelName(type.type as any, modelMap, 'undefined')},
    args: ${
      field.arguments.length > 0 ? `Args${upperFirst(field.name)}` : '{}'
    },
    ctx: ${getContextName(context)},
    info: GraphQLResolveInfo,
  )
  `  
}

function renderResolverTypeInterface(
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  context?: ContextDefinition,
): string {
  return `
  export interface ${getInterfaceName(type.name)} {
    ${type.fields
      .map(field =>
        renderResolverTypeInterfaceFunction(field, type, modelMap, context),
      )
      .join(os.EOL)}
  }
  `
}

function renderResolverTypeInterfaceFunction(
  field: GraphQLTypeField,
  type: GraphQLTypeObject,
  modelMap: ModelMap,
  context?: ContextDefinition,
): string {
  const resolverDefinition = `
  (
    parent: ${getModelName(type.type as any, modelMap, 'undefined')},
    args: ${
      field.arguments.length > 0 ? `Args${upperFirst(field.name)}` : '{}'
    },
    ctx: ${getContextName(context)},
    info: GraphQLResolveInfo,
  )
  `
  const returnType = printFieldLikeType(field, modelMap)

  if (type.name === 'Subscription') {
    return `
    ${field.name}: {
      subscribe: ${resolverDefinition} => AsyncIterator<${returnType}> | Promise<AsyncIterator<${returnType}>>
      resolve?: ${resolverDefinition} => ${returnType} | Promise<${returnType}>
    }
    `
  }

  return `
    ${
      field.name
    }: ${resolverDefinition} => ${returnType} | Promise<${returnType}>
  `
}

function renderIndex(types:  GraphQLTypeObject[]): string {
  return `
// Code generated by github.com/prisma/graphqlgen, DO NOT EDIT.
${types
  .filter(type => type.type.isObject)
  .map(type => ({
    name: type.name,
    class: getClassName(type.name),
    interface: getInterfaceName(type.name)
  }))
  .map(
    typeInfo => `
      import { ${typeInfo.class}, ${typeInfo.interface} } from './${typeInfo.name}'
    `
  )
  .join(';')}

export interface Resolvers {
  ${types
    .filter(type => type.type.isObject)
    .map(type => `${getInterfaceName(type.name)}: ${getInterfaceName(type.name)}`)
    .join(os.EOL)}
}
  `
}

function getInterfaceName(typeName: string) {
  return `I${typeName}`
}

function getClassName(typeName: string) {
  return `Base${upperFirst(typeName)}`
}